'''******************************************

Task 2: Perceptron Learning

Now starting with the initial model from section 1, use the Perceptron learning algorithm to generate updates
to the model.  Iterate through the examples in the order they are listed in the table above, and list out each updated
model generated by the algorithm.

Your algorithm should converge to a solution in less than 30 updates.    Remember to list all updated models generated
as you manually run algorithm.

******************************************'''


# Function that will compute the hypothesis of given deltas. Make sure that listOfX[0] = 0.
def hypothesis(listOfX, listOfP):
    result = listOfP[0]

    # Run a loop to add that does the following: Summation from i = 1 to n of (x of i)*(theta of i)
    for i in range(1, len(listOfP)):
        result += listOfX[i]*listOfP[i]

    return result

def printTheta(count, listOfP):
    print str(count) + ":",

    for i in range(len(listOfP)):
        print "theta(", i, ") :", "%.0f" % listOfP[i],

def main():
    # Create a list with the variables(x), outputs(y) and the thetas.
    # Ignore X(0), which should be all 1.
    #           A B
    listOfX = [[1,0,0],
               [1,0,1],
               [0,1,0],
               [1,1,1],
               [1,1,0]]

    #        A and B
    listOfY = [[0],
               [0],
               [0],
               [1],
               [1]]

    listOfP = [0, 0, 0, 0] # Number of thetas to be used is n + 1

    m = (len(listOfX))
    count = 1

    # Run the loop indefinitely until the theta values do not change
    while(True):
        # This conditional statement will check if the thetas changed through the traversal of all of the data rows.
        # The problem will only be completed if the values do not change
        thetaSame = True

        # Loop through the the data rows of the x values
        for i in range(m):
            # Display the result in the require manner. This is done to keep track of the work done
            printTheta(count, listOfP)

            count += 1
            temptheta = []

            hypothesisVal = hypothesis([0] + listOfX[i], listOfP)
            print "Hypothesis", hypothesisVal

            # Do to the classification values being either 0 or 1, if the hypothesis is greater than or equal to zero,
            # then the guess value will be 1. A negative hypothesis will result in a guess value of 0.
            if(hypothesisVal >= 0):
                guess = 1
            else:
                guess = 0

            # The change of the delta values is dependent on the relationship between the guess and the actual value.
            # If the guess is 1 and the actual value is 0, the subtract x(i) from theta(i).
            # Else if the guess is 0 and the actual value is 1, then add the x(i) to the theta(i).
            # Lastly, if the guess and the actual values are the same, then do not change the theta values.
            if (guess == 1 and listOfY[i][0] == 0):
                for j in range(len(listOfP)):
                    delta = listOfP[j] - ([1] + listOfX[i])[j]
                    temptheta.append(delta)

            elif (guess == 0 and listOfY[i][0] == 1):
                for j in range(len(listOfP)):
                    delta = listOfP[j] + ([1] + listOfX[i])[j]
                    temptheta.append(delta)
            else:
                continue

            # Check to see if theta values change. If so, set the thetaSame value to False and do not break the loop
            if(listOfP != temptheta):
                thetaSame = False

            listOfP = temptheta

        # If the theta values did not change, then break the loop and display the final results
        if(thetaSame == True):
            break

    print "\nThe thetas that produce a result are: ",
    for i in range(len(listOfP)):
        print "theta(", i, ") :", "%.0f" % listOfP[i],

main()